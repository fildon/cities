{
  "version": 3,
  "sources": ["../src/city.ts", "../src/road.ts", "../src/vector.ts", "../src/simulation.ts", "../src/index.ts"],
  "sourcesContent": ["import { Road } from \"./road\";\nimport { Vector } from \"./vector\";\n\nexport class City {\n  /**\n   * Radius of clear space required around a city\n   */\n  public static REQUIRED_SPACE = 50;\n  /**\n   * The maximum distance over which a city will connect by road to another city\n   */\n  public static ROAD_DISTANCE = 100;\n  /**\n   * The size of the city as used by system logic.\n   * Can increase only in discrete integer values.\n   */\n  logicalSize = 1;\n  /**\n   * The size as used by animation.\n   * Tends to the logical size over time, but can only increase smoothly.\n   */\n  animatedSize = 0;\n  /**\n   * The age of this city as measured in milliseconds\n   */\n  age = 0;\n  /**\n   * How long since the city last evolved in milliseconds\n   */\n  last_evolved = 0;\n  /**\n   * Whether this city is undergoing collapse\n   */\n  isCollapsing = false;\n  constructor(readonly location: Vector) {}\n\n  advanceByTime(time: number) {\n    this.age += time;\n    this.last_evolved += time;\n\n    if (this.isCollapsing) {\n      // It should take a while for a collapsing city to fully disappear\n      this.animatedSize -= time / 10000;\n      return;\n    }\n\n    if (time > 1000) {\n      this.animatedSize = this.logicalSize;\n    } else {\n      // Interpolate the animated size towards the logical size\n      this.animatedSize =\n        this.animatedSize +\n        (this.logicalSize - this.animatedSize) * (time / 1000);\n    }\n  }\n\n  /**\n   * A city should be removed when it has been collapsing,\n   * and has completely withered away to nothing\n   */\n  shouldBeRemoved() {\n    return this.isCollapsing && this.animatedSize <= 0;\n  }\n\n  isReadyToEvolve(neighbours: Array<City>) {\n    if (this.isCollapsing) return false;\n\n    // Must not have evolved recently\n    if (this.last_evolved < 1000) return false;\n\n    // Must have at least 3 connections cities larger or equal to this one\n    if (\n      neighbours.filter(\n        (neighbour) => neighbour.logicalSize >= this.logicalSize\n      ).length < 3\n    )\n      return false;\n\n    // TODO this is \"business logic\" being influenced by framerate.\n    // A purist would vomit\n    return Math.random() < 0.05;\n  }\n\n  evolve() {\n    this.logicalSize += 1;\n    this.last_evolved = 0;\n  }\n\n  /**\n   * A city is supported if it is either size 1\n   * or it is connected to at least one city exactly one size lower\n   */\n  isSupported(neighbours: Array<City>) {\n    if (this.logicalSize === 1) return true;\n    return neighbours.some(\n      (neighbour) =>\n        !neighbour.isCollapsing &&\n        neighbour.logicalSize === this.logicalSize - 1\n    );\n  }\n\n  /**\n   * Mark this city for collapse\n   */\n  collapse() {\n    this.isCollapsing = true;\n  }\n\n  paintSelf(canvas: CanvasRenderingContext2D) {\n    canvas.beginPath();\n    canvas.arc(\n      this.location.x,\n      this.location.y,\n      this.animatedSize * 5,\n      0,\n      2 * Math.PI\n    );\n    canvas.fillStyle = this.isCollapsing\n      ? // A collapsing city is grey\n        \"grey\"\n      : // Otherwise colour the city based on its size\n        [\"green\", \"yellow\", \"orange\", \"red\"][this.logicalSize - 1] ?? \"red\";\n    canvas.fill();\n\n    canvas.beginPath();\n    canvas.arc(\n      this.location.x,\n      this.location.y,\n      this.animatedSize * 5,\n      0,\n      2 * Math.PI\n    );\n    canvas.strokeStyle = \"black\";\n    canvas.lineWidth = 1;\n    canvas.stroke();\n  }\n}\n", "import { City } from \"./city\";\n\nexport class Road {\n  private created_at: number;\n  constructor(public start: City, public end: City) {\n    this.created_at = performance.now();\n  }\n\n  isMember(city: City) {\n    return [this.start, this.end].includes(city);\n  }\n\n  isMutual() {\n    return this.start.logicalSize === this.end.logicalSize;\n  }\n\n  /**\n   * A road becomes outgrown when it connects cities which differ in size too greatly\n   */\n  isOutgrown() {\n    return Math.abs(this.start.logicalSize - this.end.logicalSize) > 1;\n  }\n\n  /**\n   * The size of the smallest city connected to this road\n   */\n  getSmallest() {\n    return Math.min(this.start.logicalSize, this.end.logicalSize);\n  }\n\n  paintSelf(canvas: CanvasRenderingContext2D) {\n    const age = performance.now() - this.created_at;\n    const matured = age > 1000;\n    /**\n     * 0-1 of how complete this animation is\n     */\n    const animationParam = matured ? 1 : age / 1000;\n    const lineWidth = 2 * animationParam;\n    const opacity = animationParam / 2;\n\n    canvas.beginPath();\n    canvas.moveTo(this.start.location.x, this.start.location.y);\n    canvas.lineWidth = lineWidth;\n    canvas.lineCap = \"round\";\n    canvas.strokeStyle = `rgba(0, 0, 0, ${opacity})`;\n    canvas.lineTo(this.end.location.x, this.end.location.y);\n    canvas.stroke();\n  }\n}\n", "export class Vector {\n  constructor(public x: number, public y: number) {}\n\n  distanceBetween(other: Vector) {\n    return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);\n  }\n}\n", "import { City } from \"./city\";\nimport { Road } from \"./road\";\nimport { Vector } from \"./vector\";\n\nexport class Simulation {\n  cities: Array<City> = [];\n  roads: Array<Road> = [];\n  private static TIME_BETWEEN_CITIES = 500;\n  /**\n   * Milliseconds until the next city spawn\n   */\n  timeToNextCity = 1000;\n  constructor(private width: number, private height: number) {}\n\n  advanceByTime(time: number) {\n    // Advance all existing cities by time.\n    // Note that this deliberately excludes the cities about to be created during this step.\n    // Newly created cities will get advanced on the next frame.\n    this.cities.forEach((city) => city.advanceByTime(time));\n\n    this.timeToNextCity -= time;\n\n    let qtyToCreate = 0;\n    while (this.timeToNextCity < 0) {\n      this.timeToNextCity += Simulation.TIME_BETWEEN_CITIES;\n      qtyToCreate += 1;\n    }\n\n    this.createNewCities(qtyToCreate);\n\n    this.evolveCities();\n\n    this.collapseCities();\n\n    this.cleanDeadCities();\n  }\n\n  /**\n   * A city is dead when it should be fully removed from the simulation\n   */\n  private cleanDeadCities() {\n    const citiesToRemove = new Set(\n      this.cities.filter((city) => city.shouldBeRemoved())\n    );\n    if (citiesToRemove.size === 0) return;\n\n    this.cities = this.cities.filter((city) => !citiesToRemove.has(city));\n    // Remove associated roads\n    this.roads = this.roads.filter(\n      (road) => !citiesToRemove.has(road.start) && !citiesToRemove.has(road.end)\n    );\n  }\n\n  private neighboursForCity(city: City) {\n    return this.roads.flatMap((road) =>\n      // If the city we want is at the start, the neighbour is at the end\n      // or vice versa\n      road.start === city ? road.end : road.end === city ? road.start : []\n    );\n  }\n\n  /**\n   * Cities collapse when they are no longer supported\n   */\n  private collapseCities() {\n    this.cities\n      .filter((city) => !city.isSupported(this.neighboursForCity(city)))\n      .forEach((city) => city.collapse());\n  }\n\n  private evolveCities() {\n    const citiesToEvolve = this.cities.filter((city) =>\n      city.isReadyToEvolve(this.neighboursForCity(city))\n    );\n\n    citiesToEvolve.forEach((city) => city.evolve());\n\n    // TODO create new roads based on new city range\n\n    // Remove outgrown roads\n    this.roads = this.roads.filter((road) => !road.isOutgrown());\n  }\n\n  private createNewCities(qtyToCreate: number) {\n    while (qtyToCreate > 0) {\n      qtyToCreate -= 1;\n\n      /**\n       * Avoid building where it is too crowded.\n       * Note this this silently drops candidates which are too crowded.\n       */\n      const candidateLocation = new Vector(\n        this.width * Math.random(),\n        this.height * Math.random()\n      );\n      if (\n        this.cities.every(\n          (city) =>\n            candidateLocation.distanceBetween(city.location) >\n            City.REQUIRED_SPACE\n        )\n      ) {\n        const newCity = new City(candidateLocation);\n\n        const citiesToConnectTo = this.cities.filter(\n          (city) =>\n            city.location.distanceBetween(candidateLocation) <\n            City.ROAD_DISTANCE\n        );\n\n        const newRoads = citiesToConnectTo.map(\n          (city) => new Road(newCity, city)\n        );\n\n        if (newRoads.length > 0) {\n          this.roads = [...this.roads, ...newRoads];\n        }\n\n        this.cities.push(newCity);\n      }\n    }\n  }\n\n  paintSelf(canvas: CanvasRenderingContext2D) {\n    this.roads.forEach((road) => road.paintSelf(canvas));\n    this.cities.forEach((city) => city.paintSelf(canvas));\n  }\n}\n", "import { Simulation } from \"./simulation\";\n\nconst CANVAS_HEIGHT = 1000;\nconst CANVAS_WIDTH = 1000;\n\nconst canvasElement = document.querySelector(\"canvas\")!;\nconst canvasContext = canvasElement.getContext(\"2d\")!;\n\nconst simulation = new Simulation(1000, 1000);\n\nlet lastFrame: number | undefined;\nconst step = (now: number) => {\n  if (!lastFrame) lastFrame = now;\n  const elapsed = now - lastFrame;\n  lastFrame = now;\n\n  simulation.advanceByTime(elapsed);\n\n  canvasContext.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n  simulation.paintSelf(canvasContext);\n\n  window.requestAnimationFrame(step);\n};\n\nwindow.requestAnimationFrame(step);\n"],
  "mappings": "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",
  "names": []
}
